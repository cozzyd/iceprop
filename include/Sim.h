/***************************************************************************
 * Sim.h 
 *
 *
 * Primary simulation driver for iceprop. Dragons be here. 
 *
 * Cosmin Deaconu <cozzyd@kicp.uchicago.edu> 
 *
 * This file is part of iceprop. 
 *
 * iceprop is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * iceprop is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with iceprop.  If not, see <http://www.gnu.org/licenses/>.
 *
 *************************************************************************/ 

#ifndef ICEPROP_SIM_H
#define ICEPROP_SIM_H

#include <vector> 
class TFile; 
#include "TH2.h" 
#include <meep.hpp> 

namespace iceprop 
{


  /** This defines the geometry of the simulation */ 
  struct SimGeometry
  {
    double max_depth; /// The maximum ce depth (in m) of the simulation
    double max_r; /// The maximum radius (in m) of the simulation
    double sky_height; /// The amount of sky to simulate
    int    resolution; ///The ``resolution" (number of elements per m) 
    double pml_size; ///The size of the "perfectly matched layer" boundary condition. See Meep documentation. 

    //these are the defaults
    SimGeometry() 
    {
      max_depth = 200; 
      max_r = 500; 
      sky_height = 50; 
      resolution = 5; // (20 cm resolution by default) 
      pml_size = 5; 
    }
  }; 


  /* These are the measurements we may want */ 
  enum MeasurementType
  {
    Ez, 
    Ephi,
    Er, 
    Hz,
    Hphi,
    Hr,
    Dielectric // This won't change with time but you may want to make a histogram of it for drawing purposes
  }; 

  /* Since many things are complex quantities, we need to decide what we want to output */ 
  enum ScalarType
  {
    Real, 
    Imag, 
    Mag, 
    Phase
  }; 
  

  /* This is the output of a time domain measurement added with addTimeDomainMeasurement. Not intended to be filled in by user. */ 
  struct TimeDomainMeasurement
  {
    double r, double z; 
    MeasurementType what; 
    std::vector<double> t; 
    std::vector<std::complex<double> >  val; 

    /** make a graph of this measurement. Allocates new memory*/ 
    TGraph * makeGraph(ScalarType type = Real) const; 
  }; 

  /* This is the output of the result of trackMaximum. Not intended to be filled in by the user. */ 
  struct MaximumTracker
  {
    MeasurementType what; 
    ScalarType type; 
    TH2 * max; 
    TH2 * tmax; 
  }; 


  /* This is used to define outputs in the middle of the simulation (typically not at every step unless you like waiting forever :) ) */ 
  struct StepOutput
  {
    MeasurementType what; //default is Ez
    ScalarType type;  //default is Real
    int skip_factor;  //default is 50 
    int skip_offset; //first step to write out. default is 0. 
    const char * out_dir;  // default is current_dir 

    //For image output, the maximum scale. If zero (default), auto-scaled. For phase, if non-zero, 0-2 pi is scaled to these units. 
    double output_scale; 

    enum OutputFormat {
      PNG =1 , 
      PDF = 2, 
      ROOT = 4, 
      HDF5 = 8  
    }; 

    OutputFormat format;// output format, default is PNG | ROOT

   /* output prefix. Default of 0 makes it  autogenerated from what and type. 
    * the outputs will look like 
    *   out_dir/output_prefix.[root|hf5] 
    *   or 
    *   out_dir/output_prefix.%05d.[png|pdf] where %05d is the index (i.e. the ith output file, NOT the time or step number). This format makes it easy to use with ffmpeg. 
    */ 
    const char * output_prefix; 

    // dimensions of canvas (important for image output) . Default of 0 corresponds to  110% of histogram size. 
    int cw,ch; 
    bool double_precision; // true for double precision, otherwise single is used. Default is false. 

    StepOutput() 
    {
      what = Ez; 
      type = Real; 
      skip_factor=50; 
      skip_offset = 0; 
      out_dir = "." ; 
      output_scale = 0; 
      format = PNG | ROOT; 
      output_prefix = 0;
      cw = 0; 
      ch =0; 
      double_precision = false; 
    }
  };

  class Firn; 
  class Source; 
  class Sim
  {

    public: 
      Sim(const Firn * firn, const SimGeometry * geom, const Source * source = 0); 

      void addSource(const Source * source); 

      /* Adds a time domain measuremnt at the given position 
       *
       * skipfactor: If you don't want to record every time step, set skipfactor to something bigger than 1 
       *
       **/ 
      void addTimeDomainMeasurement(MeasurementType what, double r, double z, int skipfactor = 1);  

      /* Enables tracking the maximum of this quantity and the time at which the maximum occurs. */ 
      void trackGlobalMaximum(MeasurementType what, ScalarType type = Mag); 
      
      void addStepOutput(StepOutput output);  
      
      /** Runs the simulation for some time steps. There is no way to go back right now. Sorry.*/ 
      void run(double time); 

      /* Returns the current simulation time */ 
      double getCurrentTime() const; 

      /** Make a histogram based on the current state */ 
      TH2 * makeHist(MeasurementType what = Ez, ScalarType = Real, bool double_precision = true) const; 

      const std::vector<TimeDomainMeasurement> & getMeasurements() const  { return measurements; } 
      const std::vector<GlobalMaximum> & getMaximums() const  { return maxima; } 

      /** Low-level meep accessors. May need to hide from ROOT 5. */ 
      meep::fields & getFields() { return f; } 
      meep::fields & getVolume() { return gv; } 
      meep::fields & getStructure() { return s; } 

    private: 

      /* our stuff */ 
      const Firn * firn; 
      const SimGeometry * geom; 

      std::vector<TimeDomainMeasurement> measurements; 
      std::vector<GlobalMaximum> maxima; 
      std::vector<StepOutput> outputs; 

      /** meeps stuff. May need to hide from ROOT 5 at some point... */ 
      meep::fields f; 
      meep::grid_volume gv; 
      meep::structure s; 

  }; 
}


#endif 
